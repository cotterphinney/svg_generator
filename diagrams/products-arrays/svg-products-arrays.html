<head>
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,700' rel='stylesheet' type='text/css'>
	<link href='http://fonts.googleapis.com/css?family=Droid+Serif' rel='stylesheet' type='text/css'>
</head>

<div class="diagram image">
    <svg></svg>
</div>

<script type='text/javascript' src='https://code.jquery.com/jquery-2.1.1.min.js'></script>
<script type='text/javascript' src='../../js/generate_elements.js'></script>
<script type='text/javascript' src='../../js/initialize_page.js'></script>
<script type='text/javascript' src='../../js/static_variables.js'></script>

<script>

// Dynamic styles and attributes

var svgWidth = 315;
var svgHeight = 173;

var fontSize = '17px';
var textOffset = 20;
var mathFont = 'Droid Serif, serif';
var mathSize = '15px';

var rectWidth = 20;
var rectHeight = 20;
var rectRadius = 5;
var rectXoffset;
var rectYoffset;

var circleRadius = 10;
var circleXoffset;
var circleXoffset;

var spacingX = 60;
var spacingY = 30.5;

var integers = ['1', '2', '8', '40', '10', '1', '40', '20', '8'];

var timesSize = '11px';
var equalSize = '14.5px';
var operatorColor = '#999';

var singleDigitComma = spacingX / 2;
var doubleDigitComma = singleDigitComma - 1.5;

var bracketOffset = 29.5;

var leftMargin = 94;

// Draw diagram here


for (var i=0; i < 3; i++) {
	generateRect(leftMargin + spacingX * (i + 1) - 20.5, spacingY - 27, 40, 170, 0, 'rgba(91, 192, 222, 0.09)', 'rgba(91, 192, 222, 0)')
}

for (var i=0; i < 3; i++) {
	generateText(integers[i], leftMargin + spacingX * (i + 1), spacingY, null, mathSize, null, mathFont);
}
for (var i=3; i < 6; i++) {
	generateText(integers[i], leftMargin + spacingX * (i - 2), spacingY * 3, null, mathSize, null, mathFont);
}
for (var i=6; i < 9; i++) {
	generateText(integers[i], leftMargin + spacingX * (i - 5), spacingY * 5, null, mathSize, null, mathFont);
}

for (var i=0; i < 2; i++) {
	if (i === 0) {
		commaSpacing = doubleDigitComma;
	} else {
		commaSpacing = singleDigitComma;
	}
	console.log('eh')
	generateText(',', leftMargin + spacingX * (i + 1) + commaSpacing, spacingY, null, mathSize, null, mathFont);
}
for (var i=3; i < 5; i++) {
	if (i === 3) {
		commaSpacing = doubleDigitComma;
	} else {
		commaSpacing = singleDigitComma;
	}
	generateText(',', leftMargin + spacingX * (i - 2) + commaSpacing, spacingY * 3, null, mathSize, null, mathFont);
}
for (var i=6; i < 8; i++) {
	if (i === 6) {
		commaSpacing = doubleDigitComma;
	} else {
		commaSpacing = singleDigitComma;
	}
	generateText(',', leftMargin + spacingX * (i - 5) + commaSpacing, spacingY * 5, null, mathSize, null, mathFont);
}

for (var i=0; i < 3; i++) {
	generateText('[', leftMargin + spacingX - bracketOffset + 0.5, spacingY * (i + 1) * 2 - spacingY - 0.5, null, mathSize, null, mathFont);
}
for (var i=0; i < 3; i++) {
	generateText(']', leftMargin + spacingX * 3 + bracketOffset - 1, spacingY * (i + 1) * 2 - spacingY - 0.5, null, mathSize, null, mathFont);
}

for (var i=0; i < 3; i++) {
	var x = spacingX * (i + 1);
	var y = spacingY * 2 - 5;
	var tranformation = 'rotate(90 ' + x + ', ' + y + ')'
	generateText('x', leftMargin + x, y, null, timesSize, operatorColor);
}
for (var i=0; i < 3; i++) {
	var x = leftMargin + spacingX * (i + 1) - 5;
	var y = spacingY * 4 - 6;
	var tranformation = 'rotate(90 ' + x + ', ' + y + ')'
	generateText('=', x, y, null, equalSize, operatorColor, null, null, tranformation);
}

var lables = ['PRODUCTS BEFORE', 'EACH INDEX', 'PRODUCTS AFTER', 'EACH INDEX', 'PRODUCTS OF ALL', 'OTHER INTEGERS'];
var before = 30.5;
var after  = before * 3;
var all    = before * 5;
var label = 15;
var lineSpacing = 14.5;
var ys = [before, before + lineSpacing, after, after + lineSpacing, all, all + lineSpacing];

for (var i=0; i < 6; i++) {
	generateText(lables[i], 10, ys[i] - 7, null, '10px', null, null, 'left');
}

/*

Cheatsheet:

generateRect   ( x, y, [ width, height, borderRadius, fill, stroke, strokeWidth ])
generateCircle ( cx, cy, [ r, fill, stroke, strokeWidth ])
generateText   ( content, x, y, [ fontWeight, newFontSize, fill, fontFamily, textAnchor, transform ])
generateLine   (x1, y1, x2, y2, [ stroke, strokeWidth ])

*/

</script>