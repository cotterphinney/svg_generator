<head>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,700' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Droid+Serif' rel='stylesheet' type='text/css'>
</head>

<div class="diagram image">
    <svg></svg>
</div>

<script type='text/javascript' src='https://code.jquery.com/jquery-2.1.1.min.js'></script>
<script type='text/javascript' src='../../js/helper_functions.js'></script>
<script type='text/javascript' src='../../js/generate_elements.js'></script>
<script type='text/javascript' src='../../js/initialize_page.js'></script>
<script type='text/javascript' src='../../js/static_variables.js'></script>

<script>

// Dynamic styles and attributes

var svgWidth  = 500;
var svgHeight = 200;

var fontSize = '15px';

var mathFont = 'Droid Serif';
var icBlue   = 'rgba(91, 192, 222, 1)';
var transparent = 'rgba(255, 255, 255, 0)';

var topMargin = 60;
var leftMargin = 30;

var nodeWidth = 13;
var nodeSpacing = 40;
var nodeRadius = 4;
var nodeCircleOffset = 1;

var arrowCurve = 6;
var arrowSpacingStart = 2;
var arrowSpacingEnd = 3;
var arrowWidth = 1;
var arrowOffset = 1;
var arrowPointAngle = 151;
var arrowPointLength = 5;

var stickEndWidth = 8;
var stickOffset = 18;
var stickEndRadius = 1;

// Draw diagram here

var coordinates = [];

function generateNodeCoordinates() {
    
    for (var i=0; i<9; i++) {
        x = leftMargin + i * nodeSpacing;
        y = topMargin;
        var hypotenuseLength = Math.sqrt(2 * Math.pow(nodeSpacing, 2));
        switch(i) {
            case 6: // top
                x = x - nodeSpacing + hypotenuseLength / 2 + nodeCircleOffset;
                y = y - hypotenuseLength / 2;
                break;
            case 8: // bottom
                x = x - 3 * nodeSpacing + hypotenuseLength / 2 + nodeCircleOffset;
                y = y + hypotenuseLength / 2;
                break;
            case 7: // end
                x = x - (2 * nodeSpacing) + hypotenuseLength + 2 * nodeCircleOffset;
                break;
        }
        coordinates.push([x, y]);
    }
}

function drawNodes() {
    for (var i=0; i<coordinates.length; i++){

        generateRect(xof(i), yof(i), nodeWidth, nodeWidth, nodeRadius, transparent);

        var startx = xof(i) + nodeWidth + arrowSpacingStart;
        var starty = yof(i) + nodeWidth / 2 - arrowOffset;

        if (i === coordinates.length -1) {
            var nextIndex = 5;
        } else {
            var nextIndex = i + 1;
        }

        var endx = xof(nextIndex) - arrowSpacingEnd;
        var endy = yof(nextIndex) + nodeWidth / 2 - arrowOffset;

        switch(i) {
            case 5:
                startx = startx - arrowSpacingStart - nodeWidth / 2 - arrowOffset + arrowOffset; //
                starty = starty + arrowOffset - nodeWidth / 2 - arrowSpacingStart;
                endy = endy + arrowOffset; //
                break;
            case 6:
                starty = starty + arrowOffset; //
                endx = endx + arrowSpacingEnd + nodeWidth / 2 + arrowOffset - arrowOffset; //
                endy = endy + arrowOffset - nodeWidth / 2 - arrowSpacingEnd;
                break;
            case 7:
                startx = startx - arrowSpacingStart - nodeWidth / 2 + arrowOffset - arrowOffset; //
                starty = starty + arrowOffset + nodeWidth / 2 + arrowSpacingStart;
                endx = endx + 2 * arrowSpacingEnd + nodeWidth;
                endy = endy + 2 * arrowOffset - arrowOffset; //
                break;
            case 8:
                startx = startx - 2 * arrowSpacingStart - nodeWidth;
                starty = starty + 2 * arrowOffset - arrowOffset; //
                endx = endx + arrowSpacingEnd + nodeWidth / 2 - arrowOffset + arrowOffset; //
                endy = endy + arrowOffset + nodeWidth / 2 + arrowSpacingEnd;
                break;
        }

        var middlex = (startx + endx) / 2;
        var middley = (starty + endy) / 2;

        var deltax = endx - startx;
        var deltay = endy - starty;

        var angleStartToEnd = Math.atan(deltay / deltax);

        var curvex = middlex + arrowCurve * (Math.cos(angleStartToEnd - 90));
        var curvey = middley + arrowCurve * (Math.sin(angleStartToEnd - 90));

        if (i < 7) {
            angleStartToEnd = angleStartToEnd - 90;
        } else {
            angleStartToEnd = angleStartToEnd + 90;
        }

        var curvex = middlex + arrowCurve * (Math.cos(angleStartToEnd));
        var curvey = middley + arrowCurve * (Math.sin(angleStartToEnd));

        generateQuadraticPath(startx, starty, curvex, curvey, endx, endy, arrowWidth);

        var deltax = endx - curvex;
        var deltay = endy - curvey;

        var angleMiddleToEnd = Math.atan(deltay / deltax);

        if (i < 7) {
            var pointaAngle = angleMiddleToEnd - arrowPointAngle * Math.PI / 180;
            var pointbAngle = angleMiddleToEnd + arrowPointAngle * Math.PI / 185;
        } else {
            var pointaAngle = angleMiddleToEnd - (arrowPointAngle - 180) * Math.PI / 190;
            var pointbAngle = angleMiddleToEnd + (arrowPointAngle - 180) * Math.PI / 180;
        }

        var pointax = endx + arrowPointLength * Math.cos(pointaAngle);
        var pointay = endy + arrowPointLength * Math.sin(pointaAngle);

        var pointbx = endx + arrowPointLength * Math.cos(pointbAngle);
        var pointby = endy + arrowPointLength * Math.sin(pointbAngle);

        generateLine(endx, endy, pointax, pointay, defaultDarkColor, arrowWidth);
        generateLine(endx, endy, pointbx, pointby, defaultDarkColor, arrowWidth);
    }
}

function drawPinkStick() {
    var endCoordinates = [];
    for (var i=0; i<5; i+=4) {
        var x = xof(i) + nodeWidth / 2 - stickEndWidth / 2;
        var y = yof(i) - stickOffset;
        generateRect(x, y, stickEndWidth, stickEndWidth, stickEndRadius, defaultDarkColor);
        endCoordinates.push([x, y]);
    }
    generateLine(endCoordinates[0][0], endCoordinates[0][1] + stickEndWidth / 2, endCoordinates[1][0], endCoordinates[1][1] + stickEndWidth / 2, defaultDarkColor);
}

function drawPurpleStick() {
    var endCoordinates = [];

    var flatx = xof(3) + nodeWidth / 2 - stickEndWidth / 2;
    var flaty = yof(3) - stickOffset;
    var flatxMeet;
    generateRect(flatx, flaty, stickEndWidth, stickEndWidth, stickEndRadius, defaultDarkColor);
    endCoordinates.push([flatx, flaty]);

    var flaty = flaty + stickEndWidth / 2;

    var roundx = xof(7) + stickOffset + nodeWidth / 2;
    var roundy = yof(7) + nodeWidth / 2 - stickEndWidth / 2;
    generateRect(roundx, roundy, stickEndWidth, stickEndWidth, stickEndRadius, defaultDarkColor);
    endCoordinates.push([roundx, roundy]);

    var startx = endCoordinates[1][0] + stickEndWidth / 2;
    var starty = endCoordinates[1][1] - 1 + stickEndWidth / 2;
    var endx = endCoordinates[1][0] + stickEndWidth / 2;
    var endy = endCoordinates[1][1] + 1 + stickEndWidth / 2;

    var hypotenuseLength = Math.sqrt(2 * Math.pow(nodeSpacing, 2));

    var circleCenterx = coordinates[5][0] + hypotenuseLength / 2 + nodeWidth / 2;
    var circleCentery = coordinates[5][1] + nodeWidth / 2;
    var stickCenterx = roundx + stickEndWidth / 2;
    var stickCentery = roundy + stickEndWidth / 2;

    var distanceToRoundStick = stickCenterx - circleCenterx;

    var radiusx = distanceToRoundStick;
    var radiusy = distanceToRoundStick;


    for (var i=flatx; i<flatx+1000; i++) {
        var distanceToFlatStick = Math.sqrt( Math.pow(circleCenterx - i, 2) + Math.pow(circleCentery - flaty, 2) );
        if (distanceToFlatStick - distanceToRoundStick < 0) {
            var flatxMeet = i;
            break;
        }
    }

    var stickCurve = 4;
    var stickBlur = 1.3;

    generateArc(startx, starty, radiusx, radiusy, 0, 0, 0, flatxMeet + stickCurve / stickBlur, flaty - stickCurve);
    generateLine(flatx, flaty, flatxMeet - stickCurve, flaty, defaultDarkColor);

    generateQuadraticPath(flatxMeet - stickCurve, flaty, flatxMeet, flaty, flatxMeet + stickCurve / stickBlur, flaty - stickCurve);
}

function xof(index){
    return coordinates[index][0];
}

function yof(index){
    return coordinates[index][1];
}

generateNodeCoordinates();
drawNodes();

// drawPinkStick();
drawPurpleStick();



/*

Cheatsheet:

generateRect   ( x, y, [ width, height, borderRadius, fill, stroke, strokeWidth ])
generateCircle ( cx, cy, [ r, fill, stroke, strokeWidth ])
generateText   ( content, x, y, [ fontWeight, newFontSize, fill, fontFamily, textAnchor, transform, style ])
generateLine   (x1, y1, x2, y2, [ stroke, strokeWidth ])
generatePolygon(points, [ fill, stroke, strokeWidth ])
generateQuadraticPath(startx, starty, middlex, middley, endx, endy, [ strokeWidth, stroke, fill, isRelative ])
generateArc    (startx, starty, radiix, radiiy, rotationx, largeArc, sweep, endx, endy, [ closed, stroke, fill ])

*/

</script>