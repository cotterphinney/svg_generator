<head>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,700' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Droid+Serif' rel='stylesheet' type='text/css'>
</head>

<div class="diagram image">
    <svg></svg>
</div>

<script type='text/javascript' src='https://code.jquery.com/jquery-2.1.1.min.js'></script>
<script type='text/javascript' src='../../js/helper_functions.js'></script>
<script type='text/javascript' src='../../js/generate_elements.js'></script>
<script type='text/javascript' src='../../js/initialize_page.js'></script>
<script type='text/javascript' src='../../js/static_variables.js'></script>

<script>

// Dynamic styles and attributes

var svgWidth  = 400;
var svgHeight = 140;

var labelFontSize = '10px';
var arrayNumberFontSize = '15px';
var nodeNumberFontSize = '12px';
var positionFontSize = '10px';
var positionFontSizeSuper = '6px';

var mathFont = 'Droid Serif';
var icBlue   = 'rgba(91, 192, 222, 1)';
var transparent = 'rgba(255, 255, 255, 0)';

var topMargin = 35;
var labelMargin = 20;
var columnStart = labelMargin + 112;
var columnSpacing = 42;
var bracketOffset = 16;
var commaOffset = columnSpacing / 2 * 0.9;
var positionOffset = 0;
var rowSpacing = 31;
var bottomRowSpacing = 43;
var noPositionSpacing = 4;

var nodeRadius = 3;
var nodeWidth = 17;
var nodeOffset = nodeWidth;

var arrowOffset = 4;
var arrowPointLength = 5;
var arrowPointAngle = 40;
var arrowWidth = 1;
var highlightedArrowWidth = arrowWidth + 1;

var labels = ['ARRAY', 'POSITION', 'LINKED', 'LIST'];
var positions = ['1', 'ST', '2', 'ND', '3', 'RD', '4', 'TH', '5', 'TH', '6', 'TH'];

var positions = ['1', 'st', '2', 'nd', '3', 'rd', '4', 'th', '5', 'th', '6', 'th'];
var positionFontSizeSuper = '7px';

// Draw diagram here

// LABELS
function drawLabels() {
    for (var i=0; i<labels.length; i++) {
        var doubleLineOffset = 6;
        var y = topMargin + i * rowSpacing;
        if (i > 1) {
            y = y - rowSpacing + bottomRowSpacing;
            if (!includePosition) {
                y = y + noPositionSpacing;
            }
        }
        if (i === 2){
            y = y - doubleLineOffset;
        } else if (i === 3){
            y = y - rowSpacing + doubleLineOffset;
        }
        if (!includePosition && i > 1) {
            y = y - rowSpacing;
        }
        if (includePosition || (!includePosition && i !== 1)) {
            generateText(labels[i], labelMargin, y, null, labelFontSize, null, null, 'left');
        }
    }
}

// ARRAY NUMBERS
function drawArray(array){
    for (var i=0; i<array.length; i++) {
        var x = columnStart + i * columnSpacing;
        generateText(array[i], x, topMargin, null, arrayNumberFontSize, null, mathFont);
        
        if (i < array.length - 1) {
            generateText(',', x + commaOffset, topMargin, null, arrayNumberFontSize, null, mathFont);
        }

        var bracket;
        var bracketX;
        if (i === 0) {
            bracket = '[';
            bracketX = x - bracketOffset;
        } else if (i === array.length - 1) {
            bracket = ']';
            bracketX = x + bracketOffset;
        }
        generateText(bracket, bracketX, topMargin - 1, '300', arrayNumberFontSize);
    }
}

// POSITIONS
function drawPositions(amount){
    if (includePosition) {
        for (var i=0; i<amount * 2; i++) {
            var superOffset = 1;
            var x = columnStart + i / 2 * columnSpacing - positionOffset;
            var y = topMargin + rowSpacing;
            var fontSize = positionFontSize;
            if (i % 2) {
                fontSize = positionFontSizeSuper;
                x = x - 13;
                y = y - 3;
            }
            if (i === 1) {
                x = x - superOffset - 1;
            } else if (i === 7) {
                x = x - superOffset;
            }

            var color;
            var weight;
            if (highlightOrange2ndPosition && [2, 3].indexOf(i) >= 0) {
                color = icBlue;
                weight = 700;
            } else {
                color = defaultDarkColor;
                weight = 1;
            }
            generateText(positions[i], x, y, weight, fontSize, color);
        }
    }
}

// NODES
var nodeCoordinates = [];
function drawNodes(array){
    for (var i=0; i<array.length; i++) {
        var x = columnStart + i * columnSpacing;
        var y = topMargin + rowSpacing + bottomRowSpacing;
        if (!includePosition) {
            y = y - rowSpacing + noPositionSpacing;
        }
        var color;
        var weight;
        if (highlightOrange2ndPosition && [2, 3].indexOf(i) >= 0) {
            color = icBlue;
            weight = 700;
        } else {
            color = defaultDarkColor;
            weight = 1;
        }
        generateText(array[i], x, y, weight, nodeNumberFontSize, color);
        x = x - nodeOffset / 2;
        y = y - nodeOffset / 1.3;
        nodeCoordinates.push([x, y]);
        generateRect(x, y, nodeWidth, nodeWidth, nodeRadius, transparent);
    } 
}

// ARROWS
function drawArrows(arrayColor){

    var numbers = arrays[arrayColor].numbers;
    var ups = arrays[arrayColor].ups;
    var curves = arrays[arrayColor].curves;
    var offsets = arrays[arrayColor].offsets;
    var loopArrows = arrays[arrayColor].loopArrows;

    var width;
    var color;
    var pointLength;

    for (var i=0; i<arrays[arrayColor].numbers.length; i++) {

        var startx = xof(i, nodeCoordinates) + nodeWidth / 2 + offsets[i][0];
        var endx = xof(numbers[i] - 1, nodeCoordinates) + nodeWidth / 2 + offsets[i][1];
        var middlex = (endx + startx) / 2 ;
        
        if (ups[i]) {
            var endy = yof(numbers[i] - 1, nodeCoordinates) - arrowOffset;
            var starty = yof(i, nodeCoordinates) - arrowOffset;
            var middley = starty - curves[i];
        } else {
            var endy = yof(numbers[i] - 1, nodeCoordinates) + nodeWidth + arrowOffset;
            var starty = yof(i, nodeCoordinates) + nodeWidth + arrowOffset;
            var middley = starty + curves[i];
        }

        if (highlightLoops && loopArrows.indexOf(i) >= 0) {
            width = highlightedArrowWidth;
            color = icBlue;
            pointLength = arrowPointLength;
        } else {
            width = arrowWidth;
            color = defaultDarkColor;
            pointLength = arrowPointLength;
        }

        var color;
        var weight;
        if (highlightOrange2ndPosition && [2, 3].indexOf(i) >= 0) {
            color = icBlue;
            width = highlightedArrowWidth;
        } else {
            color = defaultDarkColor;
            weight = arrowWidth;
        }

        generateQuadraticPath(startx, starty, middlex, middley, endx, endy, width, color);

        var deltax = endx - middlex;
        var deltay = endy - middley;

        if (deltax > 0) {
            var angle = arrowPointAngle - 180;
        } else {
            var angle = arrowPointAngle;
        }

        var angleMiddleToEnd = Math.atan(deltay / deltax);

        var pointaAngle = angleMiddleToEnd - angle * Math.PI / 180;
        var pointbAngle = angleMiddleToEnd + angle * Math.PI / 185;

        var pointax = endx + pointLength * Math.cos(pointaAngle);
        var pointay = endy + pointLength * Math.sin(pointaAngle);

        var pointbx = endx + pointLength * Math.cos(pointbAngle);
        var pointby = endy + pointLength * Math.sin(pointbAngle);

        generateLine(endx, endy, pointax, pointay, color, width);
        generateLine(endx, endy, pointbx, pointby, color, width);
    }
}

var arrowOffsets = {
    1: -nodeWidth * 1/3,
    2: -nodeWidth * 1/6,
    3: 0,
    4: nodeWidth * 1/6,
    5: nodeWidth * 1/3,
}

var arrays = {
    'red': {
        'numbers': ['3', '4', '2', '3', '1', '5'],
        'ups': [true, false, true, true, true, true],
        'curves': [15, 12, 7, 7, 30, 11],
        'offsets': [
            [arrowOffsets[5], arrowOffsets[4]],
            [arrowOffsets[3], arrowOffsets[3]],
            [arrowOffsets[1], arrowOffsets[3]],
            [arrowOffsets[3], arrowOffsets[5]],
            [arrowOffsets[2], arrowOffsets[2]],
            [arrowOffsets[3], arrowOffsets[4]],
        ],
        'loopArrows': [1, 2, 3],
    },
    'orange': {
        'numbers': ['3', '1', '2', '2'],
        'ups': [false, true, true, true],
        'curves': [15, 9, 9, 22],
        'offsets': [
            [arrowOffsets[3], arrowOffsets[3]],
            [arrowOffsets[1], arrowOffsets[3]],
            [arrowOffsets[3], arrowOffsets[5]],
            [arrowOffsets[3], arrowOffsets[2]],
        ],
        'loopArrows': [0, 1, 2],
    },
    'blue': {
        'numbers': ['4', '3', '1', '1', '4'],
        'ups': [false, false, true, true, true],
        'curves': [22, 15, 12, 24, 12],
        'offsets': [
            [arrowOffsets[3], arrowOffsets[3]],
            [arrowOffsets[3], arrowOffsets[3]],
            [arrowOffsets[3], arrowOffsets[5]],
            [arrowOffsets[2], arrowOffsets[2]],
            [arrowOffsets[3], arrowOffsets[4]],
        ],
        'loopArrows': [0, 3],
    },
    'green': {
        'numbers': ['2', '3', '1', '3'],
        'ups': [false, false, true, true],
        'curves': [11, 11, 14, 11],
        'offsets': [
            [arrowOffsets[3], arrowOffsets[2]],
            [arrowOffsets[4], arrowOffsets[3]],
            [arrowOffsets[2], arrowOffsets[3]],
            [arrowOffsets[3], arrowOffsets[4]],
        ],
        'loopArrows': [0, 1, 2],
    },
}

var includePosition = true;
var highlightLoops = false;

var highlightOrange2ndPosition = true;

var arraysNames = ['red', 'orange', 'blue', 'green'];
var arrayToDraw = arraysNames[1];

drawLabels();
drawArray(arrays[arrayToDraw].numbers);
drawPositions(arrays[arrayToDraw].numbers.length);
drawNodes(arrays[arrayToDraw].numbers);
drawArrows(arrayToDraw);

/*

Cheatsheet:

generateRect   ( x, y, [ width, height, borderRadius, fill, stroke, strokeWidth ])
generateCircle ( cx, cy, [ r, fill, stroke, strokeWidth ])
generateText   ( content, x, y, [ fontWeight, newFontSize, fill, fontFamily, textAnchor, transform, style ])
generateLine   (x1, y1, x2, y2, [ stroke, strokeWidth ])
generatePolygon(points, [ fill, stroke, strokeWidth ])
generateQuadraticPath(startx, starty, middlex, middley, endx, endy, [ strokeWidth, stroke, fill, isRelative ])

*/

</script>