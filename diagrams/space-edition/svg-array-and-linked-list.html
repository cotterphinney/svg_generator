<head>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,700' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Droid+Serif' rel='stylesheet' type='text/css'>
</head>

<div class="diagram image">
    <svg></svg>
</div>

<script type='text/javascript' src='https://code.jquery.com/jquery-2.1.1.min.js'></script>
<script type='text/javascript' src='../../js/helper_functions.js'></script>
<script type='text/javascript' src='../../js/generate_elements.js'></script>
<script type='text/javascript' src='../../js/initialize_page.js'></script>
<script type='text/javascript' src='../../js/static_variables.js'></script>

<script>

// Dynamic styles and attributes

var svgWidth  = 500;
var svgHeight = 400;

var labelFontSize = '10px';
var arrayNumberFontSize = '15px';
var nodeNumberFontSize = '12px';
var positionFontSize = '10px';
var positionFontSizeSuper = '6px';

var mathFont = 'Droid Serif';
var icBlue   = 'rgba(91, 192, 222, 1)';
var transparent = 'rgba(255, 255, 255, 0)';

var topMargin = 35;
var labelMargin = 20;
var columnStart = labelMargin + 112;
var columnSpacing = 42;
var bracketOffset = 16;
var commaOffset = columnSpacing / 2 * 0.9;
var positionOffset = 2;
var rowSpacing = 50;

var nodeRadius = 3;
var nodeWidth = 17;
var nodeOffset = nodeWidth;

var arrowOffset = 4;
var arrowPointLength = 5;
var arrowPointAngle = 40;
var arrowWidth = 1;

var labels = ['ARRAY', 'POSITION', 'LINKED', 'LIST'];
var positions = ['1', 'ST', '2', 'ND', '3', 'RD', '4', 'TH', '5', 'TH', '6', 'TH'];

// Draw diagram here

// LABELS
for (var i=0; i<labels.length; i++) {
    var doubleLineOffset = 7;
    var y = topMargin + i * rowSpacing;
    if (i === 2){
        y = y - doubleLineOffset;
    } else if (i === 3){
        y = y - rowSpacing + doubleLineOffset;
    }
    generateText(labels[i], labelMargin, y, null, labelFontSize, null, null, 'left');
}

// ARRAY NUMBERS
function drawArray(array){
    for (var i=0; i<array.length; i++) {
        var x = columnStart + i * columnSpacing;
        generateText(array[i], x, topMargin, null, arrayNumberFontSize, null, mathFont);
        
        if (i < array.length - 1) {
            generateText(',', x + commaOffset, topMargin, null, arrayNumberFontSize, null, mathFont);
        }

        var bracket;
        var bracketX;
        if (i === 0) {
            bracket = '[';
            bracketX = x - bracketOffset;
        } else if (i === array.length - 1) {
            bracket = ']';
            bracketX = x + bracketOffset;
        }
        generateText(bracket, bracketX, topMargin - 1, '300', arrayNumberFontSize);
    }
}

// POSITIONS
function drawPositions(amount){
    for (var i=0; i<amount * 2; i++) {
        var x = columnStart + i / 2 * columnSpacing - positionOffset;
        var y = topMargin + rowSpacing;
        var fontSize = positionFontSize;
        if (i % 2) {
            fontSize = positionFontSizeSuper;
            x = x - 0.31 * columnSpacing;
            y = y - 3;
        }
        generateText(positions[i], x, y, null, fontSize);
    }
}

// NODES

var nodeCoordinates = [];
function drawNodes(array){
    for (var i=0; i<array.length; i++) {
        var x = columnStart + i * columnSpacing;
        var y = topMargin + 2 * rowSpacing;
        generateText(array[i], x, y, null, nodeNumberFontSize);
        x = x - nodeOffset / 2;
        y = y - nodeOffset / 1.3;
        nodeCoordinates.push([x, y]);
        generateRect(x, y, nodeWidth, nodeWidth, nodeRadius, transparent);
    } 
}

// ARROWS
function drawArrows(arrayColor){

    var numbers = arrays[arrayColor].numbers;
    var ups = arrays[arrayColor].ups;
    var curves = arrays[arrayColor].curves;
    var offsets = arrays[arrayColor].offsets;

    for (var i=0; i<arrays[arrayColor].numbers.length; i++) {

        var startx = xof(i, nodeCoordinates) + nodeWidth / 2 + offsets[i][0];
        var endx = xof(numbers[i] - 1, nodeCoordinates) + nodeWidth / 2 + offsets[i][1];
        var middlex = (endx + startx) / 2 ;
        
        if (ups[i]) {
            var endy = yof(numbers[i] - 1, nodeCoordinates) - arrowOffset;
            var starty = yof(i, nodeCoordinates) - arrowOffset;
            var middley = starty - curves[i];
        } else {
            var endy = yof(numbers[i] - 1, nodeCoordinates) + nodeWidth + arrowOffset;
            var starty = yof(i, nodeCoordinates) + nodeWidth + arrowOffset;
            var middley = starty + curves[i];
        }

        generateQuadraticPath(startx, starty, middlex, middley, endx, endy);

        var deltax = endx - middlex;
        var deltay = endy - middley;

        if (deltax > 0) {
            var angle = arrowPointAngle - 180;
        } else {
            var angle = arrowPointAngle;
        }

        var angleMiddleToEnd = Math.atan(deltay / deltax);

        var pointaAngle = angleMiddleToEnd - angle * Math.PI / 180;
        var pointbAngle = angleMiddleToEnd + angle * Math.PI / 185;

        var pointax = endx + arrowPointLength * Math.cos(pointaAngle);
        var pointay = endy + arrowPointLength * Math.sin(pointaAngle);

        var pointbx = endx + arrowPointLength * Math.cos(pointbAngle);
        var pointby = endy + arrowPointLength * Math.sin(pointbAngle);

        generateLine(endx, endy, pointax, pointay, defaultDarkColor, arrowWidth);
        generateLine(endx, endy, pointbx, pointby, defaultDarkColor, arrowWidth);
    }
}

var arrowOffsets = {
    1: -nodeWidth * 1/3,
    2: -nodeWidth * 1/6,
    3: 0,
    4: nodeWidth * 1/6,
    5: nodeWidth * 1/3,
}

var arrays = {
    'red': {
        'numbers': ['3', '4', '2', '3', '1', '5'],
        'ups': [true, false, true, true, true, true],
        'curves': [15, 12, 7, 7, 30, 11],
        'offsets': [
            [arrowOffsets[5], arrowOffsets[4]],
            [arrowOffsets[3], arrowOffsets[3]],
            [arrowOffsets[1], arrowOffsets[3]],
            [arrowOffsets[3], arrowOffsets[5]],
            [arrowOffsets[2], arrowOffsets[2]],
            [arrowOffsets[3], arrowOffsets[4]],
        ],
    },
    'orange': {
        'numbers': ['3', '1', '2', '2'],
        'ups': [false, true, true, true],
        'curves': [15, 9, 9, 22],
        'offsets': [
            [arrowOffsets[3], arrowOffsets[3]],
            [arrowOffsets[1], arrowOffsets[3]],
            [arrowOffsets[3], arrowOffsets[5]],
            [arrowOffsets[3], arrowOffsets[2]],
        ],
    },
    'blue': {
        'numbers': ['4', '3', '1', '1', '4'],
        'ups': [false, false, true, true, true],
        'curves': [22, 15, 12, 24, 12],
        'offsets': [
            [arrowOffsets[3], arrowOffsets[3]],
            [arrowOffsets[3], arrowOffsets[3]],
            [arrowOffsets[3], arrowOffsets[5]],
            [arrowOffsets[2], arrowOffsets[2]],
            [arrowOffsets[3], arrowOffsets[4]],
        ],
    },
    'green': {
        'numbers': ['2', '3', '1', '3'],
        'ups': [false, false, true, true],
        'curves': [11, 11, 14, 11],
        'offsets': [
            [arrowOffsets[3], arrowOffsets[2]],
            [arrowOffsets[4], arrowOffsets[3]],
            [arrowOffsets[2], arrowOffsets[3]],
            [arrowOffsets[3], arrowOffsets[4]],
        ],
    },
}

var arrayToDraw = 'red';

drawArray(arrays[arrayToDraw].numbers);
drawPositions(arrays[arrayToDraw].numbers.length);
drawNodes(arrays[arrayToDraw].numbers);
drawArrows(arrayToDraw);

/*

Cheatsheet:

generateRect   ( x, y, [ width, height, borderRadius, fill, stroke, strokeWidth ])
generateCircle ( cx, cy, [ r, fill, stroke, strokeWidth ])
generateText   ( content, x, y, [ fontWeight, newFontSize, fill, fontFamily, textAnchor, transform, style ])
generateLine   (x1, y1, x2, y2, [ stroke, strokeWidth ])
generatePolygon(points, [ fill, stroke, strokeWidth ])
generateQuadraticPath(startx, starty, middlex, middley, endx, endy, [ strokeWidth, stroke, fill, isRelative ])

*/

</script>