<head>
    <link rel="stylesheet" type="text/css" href="../../css/stylesheet.css">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,700' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Droid+Serif' rel='stylesheet' type='text/css'>
</head>

<div class="control-panel">
    <p id="current-diagram"></p>
    <button onclick="toggleBorder()">Toggle border</button>
    <button onclick="drawNextDiagram()">Next diagram</button>
</div>

<div class="diagram-frame border">
    <div class="diagram image">
        <svg></svg>
    </div>
</div>

<script type='text/javascript' src='https://code.jquery.com/jquery-2.1.1.min.js'></script>
<script type='text/javascript' src='../../js/index.js'></script>
<script type='text/javascript' src='../../js/helper_functions.js'></script>
<script type='text/javascript' src='../../js/generate_elements.js'></script>
<script type='text/javascript' src='../../js/initialize_page.js'></script>
<script type='text/javascript' src='../../js/static_variables.js'></script>

<script>

// Dynamic styles and attributes

var svgWidth  = 300;
var svgHeight = 400;
setSVGDimensions(svgWidth, svgHeight);

var fontSize = '10px';
var contentFontSize = '12px';
var rowLableFontSize = '13px';

var mathFont = 'Droid Serif';
var icBlue   = 'rgba(91, 192, 222, 1)';
var transparent = 'rgba(255, 255, 255, 0)';

var topMargin = 20;
var leftMargin = 50;

var containerWidth = 110;
var containerHeight = 28;
var containerColor = defaultDarkColor;
var containerStrokeWidth = 1;

var rowLabelMargin = 13;
var rowLabelVerticalOffset = 5;

var contentVerticalOffset = 2/3 * containerHeight;
var contentCharSpacing = 10;
var contentColumnOffset = 0;

var rowBorderThickness = 3;

// Draw diagram here

function drawRamContainers(numRows) {

    for (var i=0; i<numRows; i++) {
        var x = leftMargin;
        var y = topMargin + i * containerHeight;

        var mask;
        if (fadeBottomRows) {
            if (i === numRows - fadeBottomRows) {
                generateMask(y - 1, svgWidth, containerHeight * 2);
            }
            if (i >= numRows - fadeBottomRows) {
                mask = 'url(#bottom-transparent-fade)';
            }
        } else {
            mask = null;
        }

        generateLine(leftMargin, y, leftMargin, y + containerHeight, containerColor, containerStrokeWidth, mask);
        generateLine(leftMargin, y, leftMargin + containerWidth, y, containerColor, containerStrokeWidth, mask);
        generateLine(leftMargin + containerWidth, y, leftMargin + containerWidth, y + containerHeight, containerColor, containerStrokeWidth, mask);

        x = x - rowLabelMargin;
        y = y + containerHeight / 2 + rowLabelVerticalOffset;
        generateText(i, x, y, null, rowLableFontSize, null, null, null, null, null, mask);
    }

}

function drawContents(numRows) {

    var columnStarts = [
        (containerWidth - 2 * contentCharSpacing * 3) / 3 - contentColumnOffset,
        (containerWidth - 2 * contentCharSpacing * 3) / 3 * 2 + contentCharSpacing * 3 + contentColumnOffset,
    ];

    for (var row=0; row<numRows; row++) {
        for (var column=0; column<2; column++) {

            var content;
            try {
                content = contents[row][column];
            }
            catch(err) {
                content = '0000';
            }

            var x = columnStarts[column] + leftMargin; //  - (contentCharSpacing * 3 / 2);
            var y = topMargin + row * containerHeight + contentVerticalOffset;

            var mask;

            if (row >= numRows - fadeBottomRows) {
                mask = 'url(#bottom-transparent-fade)';
            } else {
                mask = null;
            }

            for (var i=0; i<4; i++) {
                generateText(content[i], x, y, null, contentFontSize, null, mathFont, 'middle', null, null, mask);
                x += contentCharSpacing;
            }
        }
    }
}

function drawBorder(color, start, end) {
    end = end || start;

    var y = topMargin + start * containerHeight;
    var height = (end - start + 1) * containerHeight;

    generateRect(leftMargin, y, containerWidth, height, 0, transparent, color, rowBorderThickness)
}


var numRows;
var isEmpty;
var contents = {};

var fadeTopRows;
var fadeBottomRows;


// all diagrams

function everyTime() {
    drawRamContainers(numRows);
    if (!isEmpty) drawContents(numRows);
}

var nameSpace = 'ram__';
var name;

function clearSettings() {
    setSVGDimensions(svgWidth, svgHeight);
    numRows = 7;
    isEmpty = true;
    fadeTopRows = 0;
    fadeBottomRows = 2;
}

var drawFunctions = [

    function ramEmpty() {
        name = nameSpace + 'ram_empty';
        numRows = 7;
    },
    function ramFull() {
        name = nameSpace + 'ram_full';
        isEmpty = false;
    },
    function border() {
        name = nameSpace + 'ram_border';
        isEmpty = false;
        drawBorder('black', 2, 4);
    }
];

var nextDiagramIndex = 0;
function drawNextDiagram() {
    replaceSVG();
    clearSettings();
    drawFunctions[nextDiagramIndex]();
    displayName(name);
    everyTime();
    nextDiagramIndex += 1;

    if (nextDiagramIndex === drawFunctions.length) {
        nextDiagramIndex = 0;
    }
}

drawNextDiagram();

/*

Cheatsheet:

generateRect   ( x, y, [ width, height, borderRadius, fill, stroke, strokeWidth ])
generateCircle ( cx, cy, [ r, fill, stroke, strokeWidth ])
generateText   ( content, x, y, [ fontWeight, newFontSize, fill, fontFamily, textAnchor, transform, style ])
generateLine   (x1, y1, x2, y2, [ stroke, strokeWidth ])
generatePolygon(points, [ fill, stroke, strokeWidth ])
generateQuadraticPath(startx, starty, middlex, middley, endx, endy, [ strokeWidth, stroke, fill, isRelative ])

*/

</script>